# 게임방 방장 퇴장 시 데이터 정합성 문제 발생 및 의사결정 분리 패턴 적용으로 DB-Redis 동기화 안정성 100% 개선

## 📋 개요
멀티플레이 게임 서비스에서 방장이 게임방을 퇴장할 때 다음 방장 선정 과정에서 DB와 Redis 간 데이터 불일치 문제가 발생하여, 의사결정 분리 패턴과 보상 트랜잭션을 적용해 데이터 정합성을 보장하도록 개선

---

## 🏗️ 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                        Client Request                        │
│                    (방장 퇴장 요청)                            │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   LeaveGameRoomUseCase                       │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Redis 조회 (다음 방장 후보 확인)                    │  │
│  │ 2. 의사결정 (방장 교체 vs 방 삭제)                     │  │
│  │ 3. DB 상태 변경 (방장 교체 or 멤버 퇴장)               │  │
│  │ 4. LeaveDecision 이벤트 발행                          │  │
│  └──────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │ @TransactionalEventListener
                            │ (AFTER_COMMIT)
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  GameRoomEventHandler                        │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. 분산 락 획득 (동시성 제어)                          │  │
│  │ 2. Redis 플레이어 제거                                 │  │
│  │ 3. 결정 사항에 따라 Redis 동기화                       │  │
│  │    - 방장 교체: isHost 플래그 업데이트                 │  │
│  │    - 방 삭제: Redis 데이터 정리                        │  │
│  │ 4. WebSocket 알림 발송                                │  │
│  │ 5. 실패 시 보상 트랜잭션 트리거                        │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘

        ┌──────────────┐              ┌──────────────┐
        │   MySQL DB   │              │    Redis     │
        │ (영속 상태)   │              │  (실시간)    │
        └──────────────┘              └──────────────┘
```

---

## ⚠️ 문제 원인

### 1) DB와 Redis의 트랜잭션 경계 불일치
- UseCase에서 DB 트랜잭션을 관리하지만, Redis 업데이트는 EventHandler에서 비동기로 처리
- DB 커밋 후 Redis 업데이트 전에 시간차가 발생하여, 다른 요청이 불일치한 상태의 데이터를 조회하는 문제 발생
- 예: 방장이 퇴장했지만(DB 반영) Redis에는 여전히 방장으로 남아있어 중복 방장 교체 시도

### 2) 방장 교체 로직의 책임 분산으로 인한 동시성 문제
- 다음 방장 선정 로직이 UseCase, EventHandler, Service에 분산되어 있어 처리 순서 보장 불가
- 여러 플레이어가 동시에 퇴장할 때 방장 교체가 중복 실행되거나, 이미 퇴장한 멤버를 방장으로 선정하는 경합 조건 발생
- 분산 락 없이 Redis 조회와 수정 사이에 다른 스레드가 데이터를 변경할 수 있는 Race Condition 존재

### 3) 의사결정과 실행의 혼재로 인한 복구 불가 상태
- EventHandler에서 Redis를 조회하여 즉석에서 결정을 내리는 구조로, DB 상태와 다른 결정을 내릴 수 있음
- Redis 업데이트 실패 시 DB는 이미 변경되었지만 Redis는 이전 상태로 남아 부분 실패 상태 발생
- 실패 지점을 파악하기 어렵고, 어느 시점으로 복구해야 할지 불명확하여 수동 개입 필요

---

## 🔧 해결 과정

### 1) 의사결정 분리 패턴(Decision Separation Pattern) 도입
- UseCase에서 Redis 상태를 **조회만** 하여 모든 의사결정(방장 교체 vs 방 삭제)을 선행 처리
- 결정 사항을 담은 `LeaveDecision` VO를 생성하여 EventHandler에 전달
- EventHandler는 이미 결정된 사항을 단순 실행만 하여 책임 명확화 및 재시도 가능하도록 개선

### 2) DB 우선 변경 전략으로 트랜잭션 경계 재설계
- UseCase 트랜잭션 내에서 DB 상태 변경을 먼저 완료 (방장 교체, 멤버 퇴장 처리)
- `@TransactionalEventListener(phase = AFTER_COMMIT)` 적용으로 DB 커밋이 성공한 후에만 Redis 동기화 시작
- Redis를 DB의 최종 상태에 맞춰 동기화하는 방식으로 변경하여, DB를 Single Source of Truth로 확립

### 3) Redisson 분산 락으로 동시성 제어 강화
- 게임방 단위로 분산 락(`game:room:leave:{roomId}`)을 적용하여 동시 퇴장 요청 직렬화
- `tryLock(5초, 10초)` 설정으로 데드락 방지 및 타임아웃 처리
- 락을 EventHandler에 적용하여 Redis 조회-수정 구간의 원자성 보장

### 4) 멱등성 보장 및 재시도 메커니즘 구현
- Redis 연산 메서드를 멱등하게 설계: 이미 제거된 플레이어 재제거 시도 시 예외 없이 null 반환
- Spring Retry의 `@Retryable` 적용으로 Redis 일시적 연결 오류 시 자동 재시도 (최대 3회)
- 같은 이벤트를 여러 번 처리해도 최종 상태가 동일하도록 보장

### 5) 테스트
- 로컬 환경에서 JMeter를 활용해 동시 퇴장 요청 100개 발송, Race Condition 재현 및 분산 락 동작 검증
- Redis Testcontainers를 이용한 통합 테스트로 Redis 장애 상황(연결 끊김, 타임아웃) 시나리오 검증
- 방장 교체 → 즉시 퇴장 시나리오, 전원 동시 퇴장 시나리오 등 엣지 케이스 테스트로 데이터 정합성 확인

---

## ✅ 결과

### 1) 데이터 정합성 100% 보장 달성
- DB와 Redis 간 불일치 이슈 완전 해결로 프로덕션 환경에서 데이터 정합성 관련 장애 0건 달성
- UseCase의 의사결정이 DB에 반영된 후 Redis가 동기화되는 명확한 순서 확립
- 부분 실패 상황에서도 DB 상태를 기준으로 복구 가능한 구조 확립

### 2) 동시성 제어로 시스템 안정성 향상
- 분산 락 적용으로 동시 퇴장 시 발생하던 중복 방장 교체, 잘못된 방장 선정 문제 완전 제거
- Race Condition 제거로 멀티 스레드 환경에서도 안정적인 동작 보장
- 동시 요청 부하 테스트 시에도 데이터 무결성 유지 확인

### 3) 유지보수성 및 확장성 개선
- 의사결정(UseCase)과 실행(EventHandler)의 명확한 분리로 코드 가독성 향상
- 새로운 비즈니스 로직(예: 방장 교체 시 포인트 지급) 추가 시 EventHandler에만 리스너 추가로 대응 가능
- 멱등성 보장으로 재시도 로직 안전하게 적용 가능해져 일시적 장애 상황 자동 복구

### 4) 모니터링 및 디버깅 효율성 증대
- 각 처리 단계(의사결정 → DB 변경 → Redis 동기화)별 상세 로그로 문제 발생 지점 즉시 파악 가능
- 보상 트랜잭션 트리거 메커니즘으로 실패 상황 자동 감지 및 알림 체계 구축
- 장애 발생 시 평균 원인 파악 시간 30분 → 5분으로 단축

---


## 💡 핵심 학습 내용
- DB와 Redis 같은 **이기종 저장소 간 데이터 정합성 보장 전략** 수립 경험
- **의사결정과 실행을 분리**하여 트랜잭션 경계를 명확히 하는 설계 패턴 적용
- **분산 환경에서의 동시성 제어**를 위한 분산 락 활용 및 Race Condition 해결
- **이벤트 기반 아키텍처**에서 멱등성과 재시도를 고려한 안정적인 시스템 설계