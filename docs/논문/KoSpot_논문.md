# KoSpot: WebSocket 기반 실시간 멀티플레이어 위치 추론 게임 시스템

## 요약 (Abstract)

본 논문은 한국의 관광지를 로드뷰를 통해 재미있게 위치를 맞추는 게임 서비스인 KoSpot의 개발 과정과 기술적 구현 방법을 제시한다. KoSpot은 사용자들이 구글 스트리트뷰와 유사한 로드뷰 환경에서 주어진 위치의 좌표를 추론하는 게임으로, 싱글 플레이어 모드와 멀티플레이어 모드를 제공한다.

본 연구에서는 실시간 멀티플레이어 게임을 구현하기 위해 WebSocket 기반의 실시간 통신 시스템을 구축하였다. STOMP 프로토콜을 활용하여 게임 상태 동기화, 플레이어 간 실시간 상호작용, 게임 타이머 동기화 등의 기능을 구현하였다. 또한 Redis를 활용한 게임 상태 관리 시스템을 설계하여 다수의 동시 접속자를 효율적으로 처리할 수 있도록 하였다.

시스템 아키텍처는 Domain-Driven Design(DDD) 원칙을 적용하여 계층형 구조로 설계하였으며, Presentation, Application, Domain, Infrastructure 계층으로 구분하여 관심사의 분리와 유지보수성을 향상시켰다. 배포는 Docker 컨테이너화와 AWS 인프라를 활용하여 확장 가능하고 안정적인 서비스를 제공하도록 구성하였다.

실제 서비스 운영 결과, 사용자들은 로드뷰를 통한 위치 추론의 재미와 지리 학습 효과에 대해 긍정적인 피드백을 제공하였으며, 멀티플레이어 기능과 랭킹 시스템이 게임 지속성을 높이는 데 기여함을 확인하였다. 다만 지리 관심도가 낮은 사용자들의 지속적 플레이 어려움과 난이도 조절의 필요성 등의 개선점도 발견되었다.

---

## 목차

1. 서론
   1.1 연구 배경 및 동기
   1.2 연구 목적
   1.3 논문 구성

2. 관련 연구

3. 시스템 아키텍처
   3.1 전체 아키텍처 개요
   3.2 계층형 아키텍처 설계
   3.3 Domain-Driven Design 적용

4. 데이터베이스 설계
   4.1 ERD 설계
   4.2 주요 엔티티 및 관계
   4.3 데이터 모델링 전략

5. 사용 기술 스택
   5.1 백엔드 프레임워크
   5.2 데이터베이스 및 캐시
   5.3 실시간 통신 기술
   5.4 인증 및 보안
   5.5 배포 및 인프라

6. 배포 시스템
   6.1 Docker 컨테이너화
   6.2 AWS 인프라 구성
   6.3 CI/CD 파이프라인

7. 주요 기능
   7.1 싱글 플레이어 게임
   7.2 멀티플레이어 게임
   7.3 랭킹 시스템
   7.4 아이템 및 포인트 시스템

8. API 설계
   8.1 RESTful API 설계 원칙
   8.2 주요 API 구조
   8.3 에러 처리 전략

9. WebSocket 기반 실시간 통신
   9.1 STOMP 프로토콜 선택 이유
   9.2 채널 구조 설계
   9.3 메시지 브로드캐스팅 메커니즘
   9.4 타이머 동기화 구현

10. 멀티플레이어 게임 구현
    10.1 게임 방 관리 전략
    10.2 플레이어 상태 동기화
    10.3 게임 플로우 설계
    10.4 라운드 관리 및 동기화
    10.5 조기 종료 로직

11. 성능 최적화
    11.1 랜덤 좌표 조회 최적화
    11.2 게임 종료 로직 비동기 처리
    11.3 Redis 캐싱 전략

12. 기대 효과 및 사용자 피드백
    12.1 긍정 피드백
    12.2 개선 피드백
    12.3 향후 개선 방향

13. 결론

참고문헌

---

## 그림 목차

그림 3-1. KoSpot 시스템 전체 아키텍처
그림 3-2. 계층형 아키텍처 구조
그림 4-1. ERD (Entity Relationship Diagram)
그림 6-1. 배포 아키텍처
그림 6-2. CI/CD 파이프라인
그림 9-1. WebSocket 채널 구조
그림 9-2. STOMP 메시지 흐름도
그림 10-1. 멀티플레이어 게임 플로우
그림 10-2. 게임 방 상태 전이도

---

## 표 목차

표 5-1. 사용 기술 스택
표 5-2. 주요 라이브러리 및 의존성
표 8-1. 주요 API 엔드포인트 분류
표 9-1. WebSocket 채널 목록
표 10-1. 게임 방 상태 정의
표 11-1. 성능 최적화 결과
표 12-1. 사용자 피드백 요약

---

## 1. 서론

### 1.1 연구 배경 및 동기

최근 게임화(Gamification)를 통한 교육 효과에 대한 관심이 높아지고 있으며, 특히 지리 교육 분야에서 인터랙티브한 학습 방법의 필요성이 대두되고 있다. 기존의 지리 학습은 주로 지도와 교과서를 통한 이론 중심의 학습이었으나, 실제 공간에 대한 이해와 직관적 학습을 제공하는 방법이 부족하였다.

한국은 다양한 관광지와 랜드마크를 보유하고 있으나, 국민들이 이러한 장소들에 대한 지리적 인식이 부족한 실정이다. 특히 젊은 세대들은 자신이 거주하는 지역 외의 다른 지역에 대한 지리적 지식이 상대적으로 부족한 편이다.

이러한 배경에서 본 연구는 로드뷰(Street View) 기술을 활용하여 사용자들이 실제 환경을 탐색하면서 위치를 추론하는 게임을 개발하고자 하였다. 게임의 재미 요소와 학습 효과를 결합하여, 사용자들이 자연스럽게 한국의 지리를 학습할 수 있는 서비스를 제공하는 것이 본 연구의 목적이다.

또한 단순한 싱글 플레이어 게임을 넘어서, 친구들과 함께 플레이할 수 있는 멀티플레이어 기능을 제공함으로써 사회적 상호작용을 통한 학습 동기 부여와 게임의 지속성을 높이고자 하였다.

### 1.2 연구 목적

본 연구의 주요 목적은 다음과 같다:

1. **실시간 멀티플레이어 게임 시스템 구축**: WebSocket 기반의 실시간 통신을 통해 여러 사용자가 동시에 게임을 플레이할 수 있는 시스템을 구현한다.

2. **게임 상태 동기화 메커니즘 개발**: Redis를 활용하여 게임 방의 상태, 플레이어 정보, 게임 진행 상황 등을 효율적으로 관리하고 동기화한다.

3. **확장 가능한 아키텍처 설계**: Domain-Driven Design 원칙을 적용하여 유지보수성과 확장성을 고려한 시스템 아키텍처를 설계한다.

4. **안정적인 서비스 배포**: Docker와 AWS를 활용하여 확장 가능하고 안정적인 클라우드 인프라를 구축한다.

5. **사용자 경험 개선**: 실제 사용자 피드백을 수집하고 분석하여 서비스 개선 방향을 도출한다.

### 1.3 논문 구성

본 논문은 다음과 같이 구성된다. 2장에서는 관련 연구를 검토하고, 3장에서는 시스템 아키텍처를 설명한다. 4장에서는 데이터베이스 설계를, 5장에서는 사용된 기술 스택을 소개한다. 6장에서는 배포 시스템을, 7장에서는 주요 기능을 설명한다. 8장에서는 API 설계를, 9장에서는 WebSocket 기반 실시간 통신 구현을 상세히 다룬다. 10장에서는 멀티플레이어 게임 구현 방법을, 11장에서는 성능 최적화를 설명한다. 12장에서는 기대 효과 및 사용자 피드백을 제시하고, 13장에서는 결론을 제시한다.

---

## 2. 관련 연구

게임화를 통한 교육 효과에 대한 연구는 다양한 분야에서 진행되어 왔다. 특히 지리 교육 분야에서는 시뮬레이션 게임과 가상 현실 기술을 활용한 연구들이 활발히 진행되고 있다.

실시간 멀티플레이어 게임 시스템의 경우, WebSocket 기술을 활용한 연구들이 다수 존재한다. WebSocket은 HTTP의 단점인 단방향 통신과 폴링(Polling)의 비효율성을 해결하기 위해 개발된 기술로, 양방향 실시간 통신을 제공한다. STOMP(Simple Text Oriented Messaging Protocol)는 WebSocket 위에서 동작하는 메시징 프로토콜로, Pub/Sub 패턴을 지원하여 멀티플레이어 게임에 적합하다.

게임 상태 관리에 있어서는 Redis와 같은 인메모리 데이터베이스가 널리 사용된다. Redis는 빠른 읽기/쓰기 성능과 다양한 데이터 구조를 제공하여 실시간 게임 상태 관리에 효과적이다.

Domain-Driven Design은 복잡한 비즈니스 로직을 가진 애플리케이션의 설계에 효과적인 방법론으로, 도메인 모델을 중심으로 한 설계를 통해 유지보수성과 확장성을 향상시킨다.

---

## 3. 시스템 아키텍처

### 3.1 전체 아키텍처 개요

KoSpot 시스템은 클라이언트-서버 아키텍처를 기반으로 하며, 웹 브라우저를 통한 접근을 지원한다. 클라이언트는 RESTful API를 통해 서버와 통신하며, 실시간 기능은 WebSocket을 통해 구현된다.

서버 측은 Spring Boot 기반의 백엔드 애플리케이션으로 구성되며, MySQL 데이터베이스에 영구 데이터를 저장하고 Redis에 임시 게임 상태를 저장한다. 이미지 파일은 AWS S3에 저장되며, 전체 시스템은 AWS EC2에서 Docker 컨테이너로 실행된다.

### 3.2 계층형 아키텍처 설계

KoSpot 시스템은 4계층 아키텍처로 구성된다:

**Presentation Layer (표현 계층)**
- HTTP 요청/응답 처리
- WebSocket 메시지 처리
- DTO 변환 및 검증
- 클라이언트와의 인터페이스 담당

**Application Layer (응용 계층)**
- 비즈니스 유스케이스 구현
- 트랜잭션 관리
- 도메인 서비스 조율
- 이벤트 발행

**Domain Layer (도메인 계층)**
- 핵심 비즈니스 로직
- 엔티티 및 값 객체
- 도메인 규칙
- 비즈니스 불변성 보장

**Infrastructure Layer (인프라 계층)**
- 데이터베이스 접근 (JPA Repository)
- 외부 서비스 연동 (Redis, S3)
- WebSocket 메시징
- 타이머 및 스케줄링

이러한 계층 분리는 관심사의 분리(Separation of Concerns) 원칙을 따르며, 각 계층의 독립적인 테스트와 유지보수를 가능하게 한다.

### 3.3 Domain-Driven Design 적용

Domain-Driven Design(DDD)은 복잡한 비즈니스 도메인을 모델링하고 구현하는 방법론이다. KoSpot 시스템에서는 다음과 같은 DDD 개념을 적용하였다:

**엔티티(Entity)**: 고유 식별자를 가진 도메인 객체
- Member: 사용자 정보
- GameRoom: 게임 방
- MultiRoadViewGame: 멀티플레이어 게임
- RoadViewGameRound: 게임 라운드

**값 객체(Value Object)**: 식별자가 없는 불변 객체
- Address: 주소 정보
- PlayStreak: 연속 플레이 정보

**도메인 서비스(Domain Service)**: 여러 엔티티에 걸친 비즈니스 로직
- GameRoomService: 게임 방 관리 로직
- RoadViewGameRoundService: 라운드 관리 로직

**리포지토리(Repository)**: 엔티티의 영속성 관리
- 각 도메인별 Repository 인터페이스 정의
- Infrastructure 계층에서 구현

이러한 구조를 통해 비즈니스 로직이 도메인 계층에 집중되어, 기술적 세부사항과 분리되어 유지보수성이 향상된다.

---

## 4. 데이터베이스 설계

### 4.1 ERD 설계

KoSpot 시스템의 데이터베이스는 다음과 같은 주요 엔티티로 구성된다:

**Member (회원)**
- 사용자 기본 정보 (아이디, 닉네임, 이메일)
- 포인트, 장착한 마커 이미지
- 현재 참여 중인 게임 방 ID

**GameRoom (게임 방)**
- 방 제목, 게임 모드, 매치 타입
- 시간 제한, 최대 인원, 비밀번호
- 호스트 정보
- 방 상태 (대기 중, 게임 중, 종료)

**MultiRoadViewGame (멀티 로드뷰 게임)**
- 게임 방과의 연관
- 현재 라운드, 총 라운드 수
- 게임 상태

**RoadViewGameRound (로드뷰 게임 라운드)**
- 게임과의 연관
- 라운드 번호, 정답 좌표
- 시간 제한, 서버 시작 시간
- 라운드 완료 여부

**GamePlayer (게임 플레이어)**
- 멤버와의 연관
- 게임과의 연관
- 팀 번호, 라운드 순위, 총 점수
- 플레이어 상태

**Coordinate (좌표)**
- 위도, 경도
- POI 이름, 주소 정보
- 지역 타입, 유효성

**Item (아이템)**
- 아이템 이름, 설명, 가격
- 재고, 아이템 타입
- 이미지 정보

**MemberItem (회원 아이템)**
- 회원과 아이템의 연관
- 구매 일시, 장착 여부

**GameRank (게임 랭크)**
- 회원과의 연관
- 게임 모드별 랭크 점수
- 티어, 레벨

**MemberStatistic (회원 통계)**
- 회원과의 일대일 관계
- 게임 모드별 통계
- 연속 플레이 정보

### 4.2 주요 엔티티 및 관계

**Member ↔ GameRoom**: 일대다 관계
- 한 회원은 여러 게임 방을 생성할 수 있음
- 한 회원은 한 번에 하나의 게임 방에만 참여 가능

**GameRoom ↔ MultiRoadViewGame**: 일대일 관계
- 한 게임 방은 하나의 게임만 진행

**MultiRoadViewGame ↔ RoadViewGameRound**: 일대다 관계
- 한 게임은 여러 라운드를 가짐

**MultiRoadViewGame ↔ GamePlayer**: 일대다 관계
- 한 게임은 여러 플레이어를 가짐

**Member ↔ GamePlayer**: 일대다 관계
- 한 회원은 여러 게임에서 플레이어로 참여

**RoadViewGameRound ↔ Coordinate**: 다대일 관계
- 한 라운드는 하나의 정답 좌표를 가짐
- 한 좌표는 여러 라운드에서 사용될 수 있음

### 4.3 데이터 모델링 전략

**정규화**: 기본적으로 3정규형을 따르되, 성능을 위해 필요한 경우 비정규화를 적용
- 라운드의 서버 시작 시간을 라운드 엔티티에 비정규화하여 저장 (타이머 동기화를 위한 빠른 조회)

**인덱싱 전략**:
- Member: username, nickname에 인덱스
- Coordinate: sido(시도)에 인덱스 (지역별 조회 최적화)
- MemberStatistic: member_id에 인덱스

**소프트 삭제**: Coordinate 엔티티에 isValid 플래그를 두어 논리적 삭제 구현

---

## 5. 사용 기술 스택

### 5.1 백엔드 프레임워크

**Spring Boot 3.4.1**
- Java 17 기반의 엔터프라이즈 애플리케이션 개발 프레임워크
- 자동 설정과 스타터 의존성을 통한 빠른 개발
- 내장 서버로 독립 실행 가능
- 선택 이유: 풍부한 생태계, 검증된 안정성, 다양한 통합 기능

**Spring Data JPA**
- JPA를 통한 객체-관계 매핑
- Repository 패턴의 자동 구현
- 쿼리 메서드 자동 생성
- 선택 이유: 생산성 향상, 타입 안정성, 코드 간결성

**Spring Security + OAuth2**
- 인증 및 권한 관리
- 소셜 로그인 지원 (구글, 네이버, 카카오)
- JWT 토큰 기반 인증
- 선택 이유: 표준 보안 프레임워크, 다양한 인증 방식 지원

### 5.2 데이터베이스 및 캐시

**MySQL 8**
- 관계형 데이터베이스
- 영구 데이터 저장
- ACID 트랜잭션 보장
- 선택 이유: 안정성, 성숙도, 넓은 사용자 기반

**Redis**
- 인메모리 데이터베이스
- 게임 방 상태, 플레이어 정보 등 임시 데이터 저장
- Pub/Sub 기능을 통한 메시징
- 선택 이유: 빠른 성능, 다양한 데이터 구조, 실시간 기능 지원

### 5.3 실시간 통신 기술

**WebSocket + STOMP**
- WebSocket: 양방향 실시간 통신
- STOMP: 메시징 프로토콜
- SockJS: WebSocket 폴백 지원
- 선택 이유: 실시간 동기화 필요, Pub/Sub 패턴 지원, 브라우저 호환성

**Spring WebSocket**
- STOMP 메시지 브로커
- 채널 기반 메시징
- 선택 이유: Spring 생태계 통합, 간편한 설정

### 5.4 인증 및 보안

**JWT (JSON Web Token)**
- Access Token과 Refresh Token 분리
- Stateless 인증
- 선택 이유: 확장성, 서버 부하 감소

**OAuth2**
- 소셜 로그인 통합
- 구글, 네이버, 카카오 지원
- 선택 이유: 사용자 편의성, 보안성

### 5.5 배포 및 인프라

**Docker**
- 애플리케이션 컨테이너화
- 일관된 실행 환경
- 선택 이유: 배포 간소화, 환경 독립성

**Docker Compose**
- 멀티 컨테이너 오케스트레이션
- Redis와 애플리케이션 통합 관리
- 선택 이유: 로컬 개발 편의성, 프로덕션 배포

**AWS (Amazon Web Services)**
- EC2: 가상 서버
- RDS: 관리형 MySQL 데이터베이스
- S3: 객체 스토리지 (이미지 저장)
- CodeDeploy: 자동 배포
- 선택 이유: 확장성, 안정성, 관리 편의성

**GitHub Actions**
- CI/CD 파이프라인
- 자동 빌드 및 배포
- 선택 이유: 무료 플랜, GitHub 통합, 간편한 설정

---

## 6. 배포 시스템

### 6.1 Docker 컨테이너화

KoSpot 애플리케이션은 Docker를 통해 컨테이너화되어 배포된다. Dockerfile은 멀티 스테이지 빌드를 사용하여 최적화된 이미지를 생성한다.

**빌드 스테이지**: Gradle을 사용하여 애플리케이션을 빌드
**런타임 스테이지**: OpenJDK 17을 기반으로 실행 환경 구성

이러한 구조는 최종 이미지 크기를 줄이고 보안을 강화한다. 또한 비루트 사용자로 실행하여 보안 취약점을 최소화한다.

Docker Compose를 통해 애플리케이션과 Redis를 함께 관리하며, 네트워크를 통한 서비스 간 통신을 구성한다.

### 6.2 AWS 인프라 구성

**EC2 인스턴스**
- Ubuntu 22.04 LTS
- Docker 및 Docker Compose 설치
- 애플리케이션 실행 환경

**RDS MySQL**
- 관리형 데이터베이스 서비스
- 자동 백업 및 패치
- 고가용성 구성

**S3 버킷**
- 이미지 파일 저장
- 정적 리소스 제공
- 버전 관리 및 라이프사이클 정책

**Nginx**
- 리버스 프록시
- SSL/TLS 종료
- 로드 밸런싱 (향후 확장 시)

### 6.3 CI/CD 파이프라인

**GitHub Actions 워크플로우**:
1. 코드 푸시 시 자동 트리거
2. 테스트 실행
3. Docker 이미지 빌드
4. S3에 배포 패키지 업로드
5. CodeDeploy를 통한 EC2 배포

**CodeDeploy 배포 단계**:
1. Before Install: 기존 컨테이너 중지
2. After Install: Docker 이미지 로드
3. Application Start: 컨테이너 시작
4. Validate Service: 헬스 체크

이러한 자동화된 파이프라인을 통해 배포 시간을 단축하고 인적 오류를 최소화한다.

---

## 7. 주요 기능

### 7.1 싱글 플레이어 게임

싱글 플레이어 게임은 연습 모드와 랭크 모드로 구분된다.

**연습 모드**: 랭크에 영향을 주지 않는 자유로운 플레이 모드
- 지역(시도) 선택 가능
- 포인트 보상 제공 (점수 기반)
- 게임 기록 저장

**랭크 모드**: 랭크 점수가 변동하는 경쟁 모드
- 랜덤 지역에서 게임 진행
- 티어별 포인트 배율 적용
- 랭크 점수 변동

각 게임은 5라운드로 구성되며, 각 라운드마다 주어진 시간 내에 정답 좌표를 추론해야 한다. 정확도에 따라 점수가 부여되며, 최종 점수에 따라 포인트와 랭크 점수가 결정된다.

### 7.2 멀티플레이어 게임

멀티플레이어 게임은 게임 방을 생성하거나 참여하여 진행된다.

**게임 방 기능**:
- 공개 방 / 비공개 방 (비밀번호 설정)
- 최대 인원 설정 (2~8명)
- 게임 모드 선택 (로드뷰, 포토)
- 매치 타입 선택 (개인전, 팀전)
- 시간 제한 설정

**게임 진행**:
- 호스트가 게임 시작
- 3초 카운트다운 후 게임 페이지로 이동
- 모든 플레이어 로딩 완료 대기 (최대 10초)
- 인트로 화면 (5초)
- 라운드 진행 (제한 시간 내 정답 제출)
- 라운드 결과 표시 및 다음 라운드 전환
- 최종 결과 및 순위 표시

**실시간 동기화**:
- 플레이어 입장/퇴장 알림
- 게임 상태 변경 알림
- 타이머 동기화
- 채팅 기능

### 7.3 랭킹 시스템

랭킹 시스템은 게임 모드별로 독립적으로 관리된다.

**티어 시스템**:
- BRONZE (0~999점)
- SILVER (1000~1499점)
- GOLD (1500~1999점)
- PLATINUM (2000~2499점)
- DIAMOND (2500~2999점)
- MASTER (3000~3499점)
- GRANDMASTER (3500~3999점)
- CHALLENGER (4000점 이상)

**랭크 점수 계산**:
- 게임 결과에 따라 점수 변동
- 상대적 성과에 따라 가감점 결정
- 중도 이탈 시 패널티 적용

### 7.4 아이템 및 포인트 시스템

**아이템 시스템**:
- 마커 스킨: 게임 내 마커 이미지 변경
- 프로필 아이템: 프로필 꾸미기
- 이펙트: 게임 내 효과
- 테마: UI 테마 변경

**포인트 시스템**:
- 게임 완료 시 포인트 획득
- 연습 모드: 기본 30P + (점수 × 0.08)
- 랭크 모드: (기본 50P + 점수 × 0.2) × 티어 배율
- 아이템 구매에 사용

---

## 8. API 설계

### 8.1 RESTful API 설계 원칙

KoSpot API는 RESTful 원칙을 따르며, 다음과 같은 설계 원칙을 적용하였다:

**리소스 중심 설계**: URL은 리소스를 나타내며, HTTP 메서드로 동작을 표현
- GET: 조회
- POST: 생성
- PUT/PATCH: 수정
- DELETE: 삭제

**일관된 응답 형식**: 모든 API는 공통 응답 형식을 사용
```json
{
  "isSuccess": true,
  "code": "2000",
  "message": "OK",
  "data": { }
}
```

**에러 처리**: HTTP 상태 코드와 커스텀 에러 코드를 함께 사용

### 8.2 주요 API 구조

**인증 API**:
- 소셜 로그인 (OAuth2)
- 토큰 재발급
- 로그아웃

**게임 API**:
- 싱글 게임 시작/종료
- 멀티 게임 방 생성/조회/참여
- 게임 시작
- 정답 제출
- 다음 라운드 진행

**회원 API**:
- 프로필 조회/수정
- 통계 조회
- 랭크 조회

**아이템 API**:
- 아이템 목록 조회
- 아이템 구매
- 아이템 장착

### 8.3 에러 처리 전략

**공통 에러 코드**:
- 2000: 성공
- 4000: 잘못된 요청
- 4001: 인증 실패
- 4002: 토큰 만료
- 4003: 권한 없음
- 4004: 리소스 없음
- 5000: 서버 에러

**도메인별 에러 코드**: 각 도메인별로 상세한 에러 코드 정의
- 게임 방 관련: 4100번대
- 게임 진행 관련: 4200번대
- 회원 관련: 4300번대

---

## 9. WebSocket 기반 실시간 통신

### 9.1 STOMP 프로토콜 선택 이유

멀티플레이어 게임에서는 여러 클라이언트 간의 실시간 동기화가 필수적이다. 이를 위해 WebSocket을 선택하였으며, STOMP 프로토콜을 사용한 이유는 다음과 같다:

1. **Pub/Sub 패턴 지원**: 게임 방 단위로 메시지를 브로드캐스트하기에 적합
2. **채널 기반 메시징**: 게임 방별, 게임 상태별로 채널을 구분하여 관리 용이
3. **Spring 통합**: Spring WebSocket과의 자연스러운 통합
4. **브라우저 호환성**: SockJS를 통한 폴백 지원

### 9.2 채널 구조 설계

WebSocket 채널은 다음과 같이 구성된다:

**글로벌 채널**:
- `/topic/lobby`: 로비 채팅

**게임 방 채널**:
- `/topic/room/{roomId}/chat`: 게임 방 채팅
- `/topic/room/{roomId}/playerList`: 플레이어 목록 변경
- `/topic/room/{roomId}/status`: 방 상태 변경
- `/topic/room/{roomId}/countdown`: 게임 시작 카운트다운

**게임 진행 채널**:
- `/topic/room/{roomId}/game/{gameId}/timer`: 타이머 동기화
- `/topic/room/{roomId}/game/{gameId}/round/{roundId}/result`: 라운드 결과
- `/topic/room/{roomId}/game/{gameId}/round/{roundId}/transition`: 라운드 전환

**메시지 전송 경로**:
- `/app/room.{roomId}.chat`: 채팅 메시지 전송
- `/app/room.{roomId}.loading.ack`: 로딩 완료 알림
- `/app/room.{roomId}.game.global.chat`: 게임 내 채팅

이러한 구조는 게임 방 단위로 메시지를 격리하여, 다른 방의 메시지가 섞이지 않도록 보장한다.

### 9.3 메시지 브로드캐스팅 메커니즘

게임 상태 변경 시 해당 게임 방의 모든 플레이어에게 메시지를 브로드캐스트해야 한다. 이를 위해 Spring의 SimpMessagingTemplate을 사용한다.

**브로드캐스트 시나리오**:
1. 플레이어 입장: `/topic/room/{roomId}/playerList`로 플레이어 목록 전송
2. 게임 시작: 카운트다운 메시지 브로드캐스트
3. 라운드 시작: 타이머 시작 메시지 브로드캐스트
4. 라운드 종료: 결과 메시지 브로드캐스트
5. 게임 종료: 최종 결과 메시지 브로드캐스트

각 메시지는 JSON 형식으로 전송되며, 클라이언트는 구독한 채널을 통해 메시지를 수신한다.

### 9.4 타이머 동기화 구현

멀티플레이어 게임에서 모든 플레이어의 타이머가 동기화되어야 한다. 이를 위해 다음과 같은 방법을 사용한다:

**서버 시간 기반 동기화**:
- 라운드 시작 시 서버 시간(서버 시작 시간)을 클라이언트에 전송
- 클라이언트는 서버 시간과 라운드 지속 시간을 받아 로컬 타이머 계산
- 5초마다 서버에서 남은 시간을 브로드캐스트하여 동기화 보정

**타이머 관리**:
- 서버에서 TaskScheduler를 사용하여 라운드 종료 시간에 이벤트 발행
- 모든 플레이어가 제출 완료 시 조기 종료 이벤트 발행
- 라운드 전환 대기 시간(10초)도 서버에서 관리

이러한 방식으로 네트워크 지연이나 클라이언트 시간 불일치 문제를 해결한다.

---

## 10. 멀티플레이어 게임 구현

### 10.1 게임 방 관리 전략

게임 방의 상태는 Redis에 저장되어 빠른 조회와 업데이트가 가능하다. Redis를 사용한 이유는 다음과 같다:

1. **빠른 성능**: 인메모리 저장으로 밀리초 단위 응답
2. **다양한 데이터 구조**: Hash, Set, List 등을 활용한 효율적 데이터 관리
3. **Pub/Sub 기능**: 메시징에도 활용 가능
4. **TTL 지원**: 자동 만료 기능으로 메모리 관리

**Redis 데이터 구조**:
- `room:{roomId}:players`: 게임 방 플레이어 정보 (Hash)
- `room:{roomId}:state`: 게임 방 상태 (String)
- `room:{roomId}:player_loading_status`: 플레이어 로딩 상태 (Hash)

게임 방의 영구 정보(제목, 설정 등)는 MySQL에 저장하고, 실시간 상태는 Redis에 저장하는 하이브리드 방식을 사용한다.

### 10.2 플레이어 상태 동기화

플레이어의 게임 내 상태는 다음과 같이 관리된다:

**플레이어 정보**:
- Redis에 현재 게임 방 ID, 팀 번호, 준비 상태 등 저장
- 게임 시작 시 GamePlayer 엔티티 생성 (MySQL)
- 게임 진행 중 점수, 순위 등은 Redis와 DB 모두 업데이트

**상태 전파**:
- 플레이어 입장/퇴장 시 WebSocket으로 브로드캐스트
- 팀 변경 시 모든 플레이어에게 알림
- 게임 시작 시 플레이어 목록 전송

### 10.3 게임 플로우 설계

멀티플레이어 게임은 다음과 같은 플로우로 진행된다:

**1. 게임 대기 (WAITING)**
- 플레이어 입장 대기
- 방 설정 변경 가능
- 채팅 가능

**2. 게임 시작 요청**
- 호스트가 게임 시작 버튼 클릭
- 최소 인원 확인 (2명 이상)
- 게임 및 첫 라운드 생성

**3. 카운트다운 (COUNTDOWN)**
- 3초 카운트다운 브로드캐스트
- 모든 플레이어에게 게임 페이지 이동 알림

**4. 로딩 단계 (LOADING)**
- 플레이어가 게임 페이지 로딩 완료 시 ACK 전송
- 모든 플레이어 로딩 완료 대기 (최대 10초)
- 타임아웃 시 미로딩 플레이어 강제 퇴장

**5. 인트로 (INTRO)**
- 라운드 문제 정보 브로드캐스트
- 5초 인트로 화면 표시

**6. 라운드 진행 (IN_ROUND)**
- 타이머 시작
- 플레이어 정답 제출
- 모든 플레이어 제출 완료 시 조기 종료

**7. 라운드 종료**
- 결과 계산 및 브로드캐스트
- 10초 전환 대기

**8. 다음 라운드 또는 게임 종료**
- 마지막 라운드가 아니면 다음 라운드 진행
- 마지막 라운드면 최종 결과 표시

### 10.4 라운드 관리 및 동기화

라운드는 게임의 기본 단위이며, 다음과 같이 관리된다:

**라운드 생성**:
- 게임 시작 시 첫 라운드 생성
- 각 라운드는 랜덤 좌표 선택
- 플레이어 ID 목록 저장

**라운드 진행**:
- 서버 시작 시간 기록 (타이머 동기화용)
- 플레이어 제출 정보는 Redis에 저장
- 제출 완료 여부는 Redis 카운터로 관리

**라운드 종료**:
- 타이머 만료 또는 모든 플레이어 제출 완료 시 종료
- 각 플레이어의 거리 계산 및 점수 부여
- 순위 계산 및 업데이트

**라운드 전환**:
- 결과 브로드캐스트 후 10초 대기
- 다음 라운드 생성 또는 게임 종료

### 10.5 조기 종료 로직

모든 플레이어가 정답을 제출하면 라운드를 조기 종료할 수 있다. 이를 통해 게임의 흐름을 빠르게 유지한다.

**구현 방법**:
1. 플레이어 제출 시 Redis 카운터 증가
2. 카운터가 플레이어 수와 같아지면 조기 종료 이벤트 발행
3. 라운드 종료 처리 실행
4. 타이머 스케줄 취소

이러한 로직은 게임의 지루함을 방지하고 플레이어의 참여도를 높인다.

---

## 11. 성능 최적화

### 11.1 랜덤 좌표 조회 최적화

게임에서 랜덤 좌표를 조회하는 작업은 빈번하게 발생한다. 초기에는 `ORDER BY RAND()`를 사용하였으나, 데이터가 많아질수록 성능이 저하되는 문제가 있었다.

**최적화 방법**:
1. **ID 범위 샘플링**: 전체 데이터의 ID 범위를 계산하고, 랜덤 ID를 선택하여 조회
2. **캐시 테이블**: 지역별 ID 범위를 미리 계산하여 캐시
3. **지역별 테이블 분리**: 시도별로 데이터를 분리하여 조회 범위 축소

이러한 최적화를 통해 조회 시간을 크게 단축하였다.

### 11.2 게임 종료 로직 비동기 처리

게임 종료 시 여러 작업이 수행된다:
- 결과 계산
- 통계 업데이트
- 포인트 지급
- 랭크 점수 업데이트

초기에는 모든 작업을 동기적으로 처리하여 응답 시간이 길었다.

**최적화 방법**:
- 주요 로직(결과 반환)은 동기 처리
- 부가 로직(통계, 포인트, 랭크)은 `@Async`를 사용한 비동기 처리
- 트랜잭션 분리로 부가 로직의 예외가 주요 로직에 영향 없도록 처리

이를 통해 응답 시간을 1400ms에서 3ms로 단축하였다.

### 11.3 Redis 캐싱 전략

Redis는 다음과 같은 용도로 활용된다:

**게임 상태 캐싱**:
- 게임 방 정보
- 플레이어 정보
- 라운드 제출 정보

**캐시 전략**:
- 자주 조회되는 데이터는 Redis에 저장
- TTL 설정으로 자동 만료
- 게임 종료 시 명시적 삭제

**캐시 무효화**:
- 데이터 변경 시 Redis와 DB 모두 업데이트
- 게임 종료 시 관련 캐시 삭제

---

## 12. 기대 효과 및 사용자 피드백

### 12.1 긍정 피드백

실제 서비스 운영을 통해 수집한 사용자 피드백은 다음과 같다:

**1. 로드뷰를 통한 위치 추론의 재미**
- "로드뷰로 둘러보면서 위치를 추측하는 것이 재밌다"
- 실제 환경을 탐색하는 과정이 게임의 핵심 재미 요소로 작용

**2. 지리 학습 효과**
- "지리에 대한 개념이 잘 없었는데, 지도를 보다보니 우리나라 지리에 대해 조금 익숙해졌다"
- 게임을 통해 자연스럽게 지리 지식 습득

**3. 멀티플레이어 기능**
- "친구랑 같이 플레이할 수 있다는 것이 재밌다"
- 사회적 상호작용을 통한 학습 동기 부여

**4. 랭킹 시스템**
- "랭킹 시스템으로 플레이 동기가 유발되어 좋다"
- 경쟁 요소가 게임 지속성에 기여

### 12.2 개선 피드백

**1. 지리 관심도가 낮은 사용자의 지속적 플레이 어려움**
- 지리에 전혀 관심이 없는 사용자들은 게임에 지속적으로 참여하기 어려움
- 해결 방안: 다양한 게임 모드 추가, 힌트 시스템 강화, 난이도 조절 옵션

**2. 난이도 조절 필요성**
- "너무 맞추기 어려운 좌표가 나오면 하고싶지 않다"
- 사용자 실력에 맞는 난이도 제공 필요
- 해결 방안: 사용자 실력 기반 좌표 추천, 난이도 선택 옵션

### 12.3 향후 개선 방향

**난이도 조절 시스템**:
- 사용자 실력 분석을 통한 적절한 난이도 제공
- 초보자용 쉬운 모드, 고수용 어려운 모드 분리
- 힌트 시스템 강화

**게임 모드 다양화**:
- 포토 모드 외 추가 모드 개발
- 퀴즈 모드, 시간 제한 모드 등

**학습 기능 강화**:
- 게임 종료 후 해당 지역 정보 제공
- 히스토리 기능으로 방문한 지역 기록
- 학습 통계 제공

**소셜 기능 강화**:
- 친구 시스템
- 리플레이 공유
- 커뮤니티 기능

---

## 13. 결론

본 연구에서는 한국의 관광지를 로드뷰를 통해 재미있게 위치를 맞추는 게임 서비스인 KoSpot을 개발하였다. WebSocket 기반의 실시간 통신 시스템을 구축하여 멀티플레이어 게임을 구현하였으며, Redis를 활용한 게임 상태 관리로 효율적인 동기화를 달성하였다.

Domain-Driven Design 원칙을 적용한 계층형 아키텍처를 통해 유지보수성과 확장성을 확보하였으며, Docker와 AWS를 활용한 클라우드 인프라로 안정적인 서비스를 제공할 수 있도록 구성하였다.

실제 서비스 운영을 통해 사용자들은 로드뷰를 통한 위치 추론의 재미와 지리 학습 효과에 대해 긍정적인 피드백을 제공하였으며, 멀티플레이어 기능과 랭킹 시스템이 게임 지속성을 높이는 데 기여함을 확인하였다.

다만 지리 관심도가 낮은 사용자들의 지속적 플레이 어려움과 난이도 조절의 필요성 등의 개선점도 발견되어, 향후 이러한 부분에 대한 개선이 필요하다.

향후 연구에서는 사용자 실력 분석을 통한 적절한 난이도 제공 시스템, 다양한 게임 모드 추가, 학습 기능 강화 등을 통해 서비스를 개선할 계획이다.

---

## 참고문헌

1. Evans, E. (2003). Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison-Wesley Professional.

2. Spring Framework Documentation. (2024). Spring WebSocket Support. https://docs.spring.io/spring-framework/reference/web/websocket.html

3. Redis Documentation. (2024). Redis Data Structures. https://redis.io/docs/data-structures/

4. Docker Documentation. (2024). Docker Overview. https://docs.docker.com/get-started/overview/

5. AWS Documentation. (2024). Amazon EC2 User Guide. https://docs.aws.amazon.com/ec2/

6. Deterding, S., Dixon, D., Khaled, R., & Nacke, L. (2011). From game design elements to gamefulness: defining "gamification". Proceedings of the 15th international academic MindTrek conference: Envisioning future media environments.

7. Zichermann, G., & Cunningham, C. (2011). Gamification by Design: Implementing Game Mechanics in Web and Mobile Apps. O'Reilly Media.

---

**작성일**: 2025년 1월
**버전**: 1.0

